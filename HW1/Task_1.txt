% Task 1 Report Section: A* Path Planning (English)
\section{Task 1: A* Path Planning in a 120\,$\times$\,120 Grid}

\subsection{Problem Description}
We consider a 120\,$\times$\,120 occupancy grid map where each grid cell represents a \SI{1.0}{m}\,$\times$\,\SI{1.0}{m} block. The robot starts from a known start position $s_0=[x_0, y_0]^\top$ and aims to reach a known goal position $s_g=[x_g, y_g]^\top$. Obstacles are encoded by the map $\texttt{world\_map}\in\{0,1\}^{120\times 120}$ where $1$ indicates an occupied cell (non-traversable) and $0$ indicates a free cell.
The motion model is 4-connected (up, down, left, right) with unit step cost.

\subsection{Formulation}
Let the state space be $\mathcal{S}=\{(x,y)\in\mathbb{Z}^2\mid 0\le x,y < 120\}\setminus\mathcal{O}$ where $\mathcal{O}$ is the set of obstacle cells. The neighbor function for 4-connectivity is
\[
\mathcal{N}_4(s) = \{(x\pm1,y),\,(x,y\pm1)\}\cap\mathcal{S}.
\]
We define the path cost $g(s)$ as the length (number of steps) from $s_0$ to state $s$ along the discovered path, and use the Manhattan heuristic as an estimate to the goal:
\[
h(s) = |x-x_g| + |y-y_g|.
\]
The A* evaluation function is
\[
f(s) = g(s) + h(s).
\]
For 4-connected grids with unit step cost, the Manhattan distance is both \emph{admissible} (never overestimates the true shortest path) and \emph{consistent} (monotone): for any neighboring states $s$ and $s'$, $h(s)\le 1 + h(s')$. Therefore, A* guided by $h$ is complete and optimal.

\subsection{Algorithm Description and Implementation}
We implement A* with the following data structures:
\begin{itemize}
	\item \textbf{Open set} (frontier): a priority queue keyed by $(f(s), \text{tie})$ implemented via \texttt{heapdict}, which supports efficient key updates (decrease-key behavior).
	\item \textbf{Closed set} (visited): a hash set of states that have been expanded and for which the optimal $g$-value has been determined (under a consistent heuristic).
	\item \textbf{came\_from}: a hash map storing the best predecessor of each discovered state for path reconstruction.
	\item \textbf{$g$-score}: a hash map storing the current best-known path cost to each discovered state.
\end{itemize}

\paragraph{Overall A* workflow.}
\begin{enumerate}
	\item \textbf{Initialization:} set $g(s_0)=0$, compute $f(s_0)=g(s_0)+h(s_0)$, insert $s_0$ into the open set with priority $(f,\,\text{tie})$; clear the closed set.
	\item \textbf{Main loop:} while the open set is not empty:
	\begin{enumerate}
		\item Pop the state $s$ with minimal $(f,\,\text{tie})$ from the open set.
		\item If $s=s_g$, terminate and reconstruct the path by following \texttt{came\_from} backwards from $s_g$ to $s_0$.
		\item Insert $s$ into the closed set.
		\item For each neighbor $s'\in\mathcal{N}_4(s)$ that is in bounds and not an obstacle:
		\begin{enumerate}
			\item Compute $\tilde g = g(s)+1$.
			\item If $s'\in$ closed and $\tilde g \ge g(s')$, continue.
			\item If $s'$ is unseen or $\tilde g < g(s')$, then set $g(s')\leftarrow \tilde g$, $f(s')\leftarrow g(s')+h(s')$, \texttt{came\_from}$[s']\leftarrow s$, and insert/update $s'$ in the open set with priority $(f(s'),\,\text{tie})$.
		\end{enumerate}
	\end{enumerate}
	\item \textbf{Failure:} if the open set becomes empty before reaching $s_g$, report that no feasible path exists.
\end{enumerate}

To avoid ambiguity when multiple nodes have the same $f$-value, we use a monotonically increasing counter as a secondary key (\emph{tie-breaker}). This yields deterministic and stable behavior without affecting optimality.

\paragraph{Neighbor expansion.} For each neighbor $s'\in\mathcal{N}_4(s)$ that is within bounds and not an obstacle, we compute a tentative cost $\tilde g = g(s)+1$. If $\tilde g < g(s')$ (or $s'$ is unseen), we update
\[
g(s')\leftarrow \tilde g,\quad f(s')\leftarrow g(s') + h(s'),\quad \texttt{came\_from}[s']\leftarrow s,
\]
and insert/update $s'$ in the open set with priority $(f(s'),\,\text{tie})$.

\paragraph{Safety.} The algorithm never inserts obstacle cells into the open set (explicit check against $\texttt{world\_map}[x][y]=1$), hence every returned path is collision-free with respect to the provided occupancy grid.

\paragraph{Correctness.} With a consistent heuristic, when a state is extracted from the open set, its $g$-value is already optimal; thus it need not be reopened. Consequently, the first time we pop $s_g$ we obtain an optimal path. If the open set exhausts before reaching $s_g$, no feasible path exists.

\subsection{Complexity}
Let $V$ be the number of traversable cells and $E$ the number of edges (at most $4V$ for a 4-connected grid). Using a binary heapâ€“based priority queue, A* runs in
\[
\mathcal{O}(E\log V)
\]
time and $\mathcal{O}(V)$ memory. In our 120\,$\times$\,120 map, $V\le 14{,}400$.

\subsection{Implementation Notes}
\begin{itemize}
	\item \textbf{Grid/world mapping:} indices follow the array convention $\texttt{world\_map}[x][y]$, and plots use the same $(x,y)$ ordering for consistency.
	\item \textbf{Move set:} 4-connected moves with unit cost; no diagonal motion in Task~1.
	\item \textbf{Priority queue:} \texttt{heapdict} allows updating priorities via assignment, simplifying the typical ``if-in-open then decrease-key'' branching.
	\item \textbf{Tie-breaking:} a counter ensures stable ordering among nodes with identical $f$.
\end{itemize}

\subsection{Results and Visualization}
Figure~\ref{fig:task1} shows a representative path produced by A* from the given start to the goal on the provided map. The red polyline is the planned path, blue and red crosses denote goal and start, and black dots indicate obstacles.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.62\linewidth]{Figures/Task_1.png}
	\caption{A* path on the 120\,$\times$\,120 map (Task~1).}
	\label{fig:task1}
\end{figure}

\subsection{Discussion}
	extbf{Optimality and completeness.} With the Manhattan heuristic under 4-connected, unit-cost moves, A* is both complete (finds a path if it exists) and optimal (the first returned path has minimal number of steps).

	extbf{Determinism.} The tie-breaker counter yields deterministic behavior across runs and platforms when $f$ ties occur, without changing the theoretical guarantees.

	extbf{Limitations.} Task~1 restricts motion to 4-connectivity and unit costs, which may yield paths with many orthogonal turns. Smoother paths (Task~3) or improved heuristics/expansions (e.g., 8-connected moves with a consistent heuristic) can reduce path length or turning effort at the expense of modified optimality criteria.

\subsection{Evaluation: Computational Time, Safety, and Optimality}
	extbf{In terms of computational time,} A* with a binary-heap priority queue has a worst-case complexity of $\mathcal{O}(E\log V)$ where $V$ is the number of traversable cells and $E\le 4V$ under 4-connectivity. In our implementation, we additionally report \emph{wall-clock time} measured via \texttt{time.perf\_counter()}, the number of \emph{expanded nodes} (states moved into the closed set), and the \emph{path steps} (edges along the returned path). These metrics are printed to the console when the script finishes; they can be directly cited in the report for empirical runtime evidence.

	extbf{In terms of safety,} we check bounds and occupancy before enqueuing neighbors and never insert obstacle cells (with $\texttt{world\_map}[x][y]=1$) into the open set. Hence every returned path is collision-free with respect to the given static occupancy grid. Safety thus relies on the map fidelity; if sensing or mapping is imperfect, optional inflation of obstacles or safety margins could be introduced but is beyond Task~1.

	extbf{In terms of optimality,} using the Manhattan heuristic on a 4-connected, unit-cost grid is both \emph{admissible} and \emph{consistent}, ensuring that the first time the goal is popped from the open set, the path has minimal number of grid steps. The tie-breaker counter only affects the expansion order among nodes with the same $f$ but does not affect the optimality guarantee.

\paragraph{Empirical results (Task 1).}
For the provided map and start/goal configuration, one representative run reports:
\begin{center}
\begin{tabular}{l r}
\hline
Computational time (ms) & 58.70 \\
Expanded nodes & 6176 \\
Path steps & 180 \\
\hline
\end{tabular}
\end{center}
These results indicate that A* finds a feasible path of 180 grid steps with a moderate search effort (6.2k expansions) and sub-\SI{100}{ms} wall-clock time on our machine, which aligns with the expected $\mathcal{O}(E\log V)$ behavior on a 120\,$\times$\,120 grid.

