\section{Task 2: Improved A* Algorithm}

\subsection{Problem Formulation}

We consider a 120\,$\times$\,120 occupancy grid map where each grid cell represents a \SI{1.0}{m}\,$\times$\,\SI{1.0}{m} block. The robot starts from a known start position $s_s=(x_s, y_s)$ and aims to reach a known goal position $s_g=(x_g, y_g)$. Obstacles are encoded by $\texttt{world\_map}\in\{0,1\}^{120\times 120}$ where $1$ indicates an occupied cell (non-traversable) and $0$ indicates a free cell.
The motion model is 8-connected (up, down, left, right, upper left, upper right, bottom left, bottom right) with step cost as follow:
\[
cost_{\text{step}}(s\to s')=\begin{cases}1, & \text{axis-aligned} \\ \sqrt{2}, & \text{diagonal}\end{cases}.
\]

\subsection{Method}

The neighbor function for 8-connectivity is
\[
\mathcal{N}_8(s)=\{(x\pm1,y),\,(x,y\pm1),\,(x\pm1,y\pm1)\}\cap\mathcal{S}.
\]

We define the path cost $g(s)$ by augmenting the step cost with two penalties:
\[
g(s') \leftarrow g(s) + \underbrace{\text{cost}_{\text{step}}(s\to s')}_{\text{cost}_{\text{step}}} + \underbrace{\frac{w_{\text{obs}}}{d(s')+1}}_{\text{cost}_{\text{safety}}} + \underbrace{w_{\text{turn}}\,\mathbf{1}[\,\text{dir}(s\to s')\ne\text{dir}(\text{parent}(s)\to s)\,]}_{\text{cost}_{\text{turn}}},
\]
where $d(s')$ is the distance from $s'$ to the nearest obstacle; $w_{\text{obs}}$ and $w_{\text{turn}}$ are non-negative weights; and $\mathbf{1}[\cdot]$ is the indicator function.

The heuristic is the octile distance
\[
h(s)=(\sqrt{2}-1)\min\{|x-x_g|,|y-y_g|\}+\max\{|x-x_g|,|y-y_g|\}.
\]
The A* evaluation function is
\[
f(s)=g(s)+h(s).
\]

We implement the \textbf{improved A* algorithm} with the following data structures:
\begin{itemize}
	\item \textbf{open\_set}: a priority queue keyed by $f(s)$ implemented via \texttt{heapdict}, which supports efficient key updates.
	\item \textbf{closed\_set}: a hash set of states that have been expanded and for which the optimal $g$-value has been determined.
	\item \textbf{parent}: a hash map storing the best predecessor of each discovered state for path reconstruction.
	\item \textbf{$g$-score}: a hash map storing the current best-known path cost to each discovered state.
	\item \textbf{last\_dir}: a hash map storing the incoming motion direction for each state.
	\item \textbf{dist\_map}: a map giving the distance from any free cell to the nearest obstacle.
    \item \textbf{safety\_buffer}: states with $d(s)\le \texttt{safety\_buffer}$ are treated as non-traversable.
\end{itemize}

The \textbf{improved A* algorithm} works as follow:
\begin{enumerate}
	\item \textbf{Initialization:} compute the \textbf{dist\_map} on the free-space mask; set $g(s_s)=0$ and $\texttt{last\_dir}[s_s]=\text{None}$; compute $f(s_s)=h(s_s)$ and insert $s_s$ into \texttt{open\_set} keyed by $f$.
	\item \textbf{Main loop:} while \texttt{open\_set} is not empty:
	\begin{enumerate}
		\item Pop the state $s$ with minimal $f(s)$ from \texttt{open\_set}.
		\item If $s=s_g$, terminate and reconstruct the path by following \texttt{parent} backwards from $s_g$ to $s_s$.
		\item Insert $s$ into \texttt{closed\_set}.
		\item For each neighbor $s'\in\mathcal{N}_8(s)$ that is in bounds and not an obstacle:
		\begin{enumerate}
			\item If $d(s')\le \texttt{safety\_buffer}$, skip $s'$ (treated as non-traversable).
			\item Let $\text{cost}_{\text{step}}=1$ for axis-aligned moves and $\sqrt{2}$ for diagonals.
			\item Let $\text{cost}_{\text{safety}}=\frac{w_{\text{obs}}}{d(s')+1}$.
			\item Let $\text{cost}_{\text{turn}}=w_{\text{turn}}$ if the direction from $s$ to $s'$ differs from $\texttt{last\_dir}[s]$, else $0$.
			\item Compute $\tilde g = g(s)+\text{cost}_{\text{step}}+\text{cost}_{\text{safety}}+\text{cost}_{\text{turn}}$.
			\item If $s'\in$ \texttt{closed\_set} and $\tilde g \ge g(s')$, continue.
			\item If $s'$ is unseen or $\tilde g < g(s')$, set $g(s')\leftarrow \tilde g$, $f(s')\leftarrow g(s')+h(s')$, \texttt{parent}$[s']\leftarrow s$, \texttt{last\_dir}$[s']\leftarrow \text{dir}(s\to s')$, and insert/update $s'$ in \texttt{open\_set} with priority $f(s')$.
		\end{enumerate}
	\end{enumerate}
	\item \textbf{Failure:} if \texttt{open\_set} becomes empty before reaching $s_g$, report that no feasible path exists.
\end{enumerate}

\subsection{Result Analysis}

Figure~\ref{fig:task2} shows a representative path produced by \textbf{improved A* algorithm} from the given start to the goal on the provided map. The red polyline is the planned path, blue and red crosses denote goal and start, and black dots indicate obstacles. We set $w_{\text{obs}}=3$, $w_{\text{turn}}=0.5$ and $\texttt{safety\_buffer}=3.0$.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\linewidth]{Figures/Task_2.png}
	\caption{A* path on the 120\,$\times$\,120 map (Task~2).}
	\label{fig:task2}
\end{figure}

In terms of \textbf{computational time}, the computational time of the \textbf{improved A* algorithm} is \SI{184.21}{ms}, which is about three times of the \textbf{basic A* algorithm}.

In terms of \textbf{safety}, with the introduction of $w_{\text{obs}}$ (close-to-obstacle penalty) and $w_{\text{turn}}$ (turning penalty), the \textbf{improved A* algorithm} encourages paths with fewer direction changes and larger clearance from obstacles. In our run, the final path contains only \textbf{7 turns}. Beyond the soft penalty, we also enforce a \emph{hard} safety buffer by setting $\texttt{safety\_buffer}=\mathbf{3.0}$ cells, i.e., any state with $d(s)\le3.0$ is treated as non-traversable. Compared to the \textbf{basic A* algorithm}, this strengthens safety by both discouraging near-obstacle traversal and forbidding it within the buffer.


In terms of \textbf{optimality}, using the octile heuristic on a 8-connected grid is both \emph{admissible} and \emph{consistent}, and penalties are added only to $g$, not to $h$. Therefore, the first time the goal is popped from \texttt{open\_set}, the path is optimal with respect to the augmented cost($\text{cost}_{\text{step}}$ + $\text{cost}_{\text{safety}}$ + $\text{cost}_{\text{turn}}$). Thus, both \textbf{basic A* algorithm} and \textbf{improved A* algorithm} are optimal.